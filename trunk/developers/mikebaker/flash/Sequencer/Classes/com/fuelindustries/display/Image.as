package com.fuelindustries.display {	import com.fuelindustries.core.AssetProxy;	import com.fuelindustries.core.FuelUI;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Loader;	import flash.display.LoaderInfo;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.net.URLRequest;	/**	 * @author jdolce	 * A really simple container for loading and displaying bitmaps	 */	public class Image extends FuelUI 	{		/** @private */		protected var __bitmap:Bitmap;		/** @private */		protected var __loadingError:Boolean;				private var __shouldCenter:Boolean;		private var __isLoaded:Boolean;		private var __url:String;				private var __width:Number;		private var __height:Number;				private var __widthSet:Boolean;		private var __heightSet:Boolean;				private var __loader:Loader;						override public function set width( w:Number ):void		{			setWidth( w );		}				override public function get width():Number		{			return( __width );			}				override public function set height( h:Number ):void		{			setHeight( h );		}		override public function get height():Number		{			return( __height );			}				/**		* Gets the URL of the externally loaded bitmap		**/		public function get url():String		{			return( __url );			}				/**		* Returns the BitmapData of the current bitmap object		**/		public function get bitmapData():BitmapData		{			return( __bitmap.bitmapData );			}				/**		* Determines whether the bitmap has been loaded yet.		**/		public function get isLoaded():Boolean		{			return( __isLoaded );			}				public function Image()		{			__widthSet = false;			__heightSet = false;			maintainClassReference = true;			linkage = AssetProxy.BLANK_MOVIECLIP;		}		override protected function completeConstruction():void		{			super.completeConstruction();			__loadingError = false;			__isLoaded = false;			__shouldCenter = false;			}				/**		* loads an external Bitmap from a url.		* @param url the url to the external bitmap to be loaded		**/		public function loadImage( url:String ):void		{			__loadingError = false;			__isLoaded = false;			var request:URLRequest = new URLRequest( url );			__loader = new Loader();			__loader.contentLoaderInfo.addEventListener( Event.COMPLETE, imageComplete );			__loader.contentLoaderInfo.addEventListener( ProgressEvent.PROGRESS, progressUpdate );			__loader.contentLoaderInfo.addEventListener( IOErrorEvent.IO_ERROR, ioError );			__loader.load( request );				}				/**		* If the bitmap is in the process of being loaded calling this method closes the connection		* and stops any further loading.		**/		public function stopLoading():void		{						if( !__isLoaded )			{				try				{					__loader.close();				}				catch( e:Error )				{					debug( e.message );				}								disposeLoader();			}		}				/**		* This method sets the bitmap object to the specified BitmapObject		* This can be handy to display a default image if there is an error during loading.		* @param abitmap the Bitmap object to be used.		**/				public function setBitmap( abitmap:Bitmap ):void		{			__bitmap = abitmap;			addChild( __bitmap );			if( __widthSet ) __bitmap.width = __width;			if( __heightSet ) __bitmap.height = __height;			__width = __bitmap.width;			__height = __bitmap.height;					if( __shouldCenter )			{				centerImage();			}						dispatchEvent( new Event( Event.COMPLETE ));			}				/**		* This method centers the image so that it's registration point will be the center of the image.		* This can be called at any time and will always keep the bitmap centered even if it's width and height properties are changed		**/		public function centerImage():void		{				__shouldCenter = true;						if( __bitmap != null )			{				__bitmap.x = -Math.round( __bitmap.width/2 );				__bitmap.y = -Math.round( __bitmap.height/2 );			}		}				/**		* disposes of the Bitmap and it's BitmapData		* Should be called when you are done with the Bitmap in order for it to be cleared from memeory properly		**/		public function dispose():void		{			if( __bitmap != null )			{				removeChild( __bitmap );				__bitmap.bitmapData.dispose();				__bitmap = null;			}		}				protected function ioError( e:Event ):void		{			__loadingError = true;			imageComplete( e );			}				private function progressUpdate( e:ProgressEvent ):void		{			dispatchEvent( e );		}				private function disposeLoader():void		{			var target:LoaderInfo = __loader.contentLoaderInfo as LoaderInfo;			target.removeEventListener( Event.COMPLETE, imageComplete );			target.removeEventListener( ProgressEvent.PROGRESS, progressUpdate );			target.removeEventListener( IOErrorEvent.IO_ERROR, ioError );		}				protected function imageComplete( e:Event ):void		{			disposeLoader();						var target:LoaderInfo = e.target as LoaderInfo;						if( !__loadingError )			{				setBitmap( Bitmap( target.content ) );			}						__isLoaded = true;		}								private function setHeight(h:Number):void		{			__heightSet = true;			__height = h;						if( __bitmap != null )			{				__bitmap.height = h;				if( __shouldCenter )				{					centerImage();					}			}		}				private function setWidth(w:Number):void		{			__widthSet = true;			__width = w;						if( __bitmap != null )			{				__bitmap.width = w;				if( __shouldCenter )				{					centerImage();					}			}					}				override protected function onRemoved():void		{			super.onRemoved();			if( __bitmap != null )			{				removeChild( __bitmap );				}						if( __loader != null )			{				disposeLoader();				__loader = null;				}					}	}}