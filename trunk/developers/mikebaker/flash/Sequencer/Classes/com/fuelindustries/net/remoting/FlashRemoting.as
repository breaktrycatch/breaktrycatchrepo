package com.fuelindustries.net.remoting {	import com.fuelindustries.events.RemotingEvent;	import com.hurlant.crypto.hash.MD5;	import flash.events.NetStatusEvent;	import flash.net.NetConnection;	import flash.net.Responder;	import flash.utils.ByteArray;	/**	 * The FlashRemoting class is to be used for all comunication with the server in AMF format.	* 	*   import com.fuelindustries.net.remoting.*;	*	import com.hurlant.crypto.hash.MD5;	*	import com.fuelindustries.events.*;	*	import com.fuelindustries.debug.*;	*		*	var url:String = "http://2coreys-dev.fuelindustries.com/FuelAMFGateway.aspx";	*	var sessionId:int = 1517;	*	var page:int = 1;	*	var itemsPerPage:int = 10;	*	var type:int = 2;	*	var service:String = "GetLeaderboard";	*		*	var fr:FlashRemoting = new FlashRemoting("AandE.TwoCoreys.Leaderboard, AandE.TwoCoreys.Web");	*	fr.addEventListener( RemotingEvent.SUCCESS, onSuccess );	*	fr.addEventListener( RemotingEvent.FAILURE, onFailure );	*	fr.connect( url );	*		*	var hash:String = fr.createHash( "susie", sessionId, page, itemsPerPage, type);	*	fr.call(service, sessionId, page, itemsPerPage, type, hash );	*		*	function onSuccess( event:RemotingEvent ):void	*	{	*		trace( event );	*		Log.debugObject( event.info );	*	}	*		*	function onFailure( event:RemotingEvent ):void	*	{	*		trace( event );	*		trace( "ON FAILURE", event.info.description );	*	}	* 	*/	public class FlashRemoting extends BaseRemoting 	{		private var __nc:NetConnection;		private var __service:String;		private var __responder:Responder;		private var __encoding:uint;		private var __url:String;		private var __method:String;				/**		* gets the gateway url that you are connected to		*/		public function get url():String		{			return( __url );			}				/**		* gets the service or method that you are trying to call		*/		public function get service():String		{			return( __service );			}						/**		* gets the AMF protocol used. BaseRemoting.AMF0 and BaseRemoting.AMF3;		*/		public function get objectEncoding():uint		{			return( __encoding );			}						/**		 * Creates a new FlashRemoting object with the specified parameters. 		 *          * @param service The service name. For example AandE.TwoCoreys.Leaderboard, AandE.TwoCoreys.Web         * @param objectEncoding The AMF encoding protocol to use. BaseRemoting.AMF0 or BaseRemoting.AMF3		 */		public function FlashRemoting( service:String, objectEncoding:uint = 0) 		{			__encoding = objectEncoding;			__service = service;			init();		}				/**		 * Connects to the gateway url		 *          * @param url The gatewayurl of the service.		 */		public function connect( url:String ):void		{			__nc.connect( url );			__url = url;		}				/**		 * Calls a specific function on the service.		 * Optional params are passed in just like you where calling the function directly.		 *          * @param method The method that you are calling.		 */		public function call( method:String, ...args:Array ):void		{			__method = method; 			var service:String = __service.length ? __service + "." + method : method;			__service = service;			__nc.call.apply(__nc, [service, __responder].concat(args));		}				/**		 * Creates and returns the hash based on it's parameters		 * Optional params are passed to create the params. These params will be determined by the serverside and supplied to you in an api.		 *          * @param key The key to use for encoding.		 */		public function createHash( key:String, ...args:Array ):String		{			var str:String = "";						for( var k:int = 0; k<args.length; k++ )			{				str += args[ k ];				}						str += key;									var hashArray:ByteArray = new ByteArray();			hashArray.writeUTFBytes( str );			var md5:MD5 = new MD5();			var md5Hash:ByteArray = md5.hash(hashArray);			var table:String = "0123456789abcdef";			var hexString:String = "";			for (var i:int = 0;i < md5Hash.length*4;i += 4)			{				hexString += table.charAt((md5Hash[i >> 2] >> ((i%4)*8+4)) & 0xF) + table.charAt((md5Hash[i >> 2] >> ((i%4)*8)) & 0xF);			}			return (hexString);		}				private function init():void		{			__nc = new NetConnection();			__nc.objectEncoding = __encoding;			__nc.addEventListener( NetStatusEvent.NET_STATUS, onStatus, false, 0, true);			__responder = new Responder(onResult, onFault);			}				private function onStatus( event:NetStatusEvent ):void		{			var code:String = event.info as String;			switch (code)			{				case "NetConnection.Call.Failed":				case "NetConnection.Call.Prohibited":				case "NetConnection.Call.BadVersion":				case "NetConnection.Connect.Failed":				case "NetConnection.Connect.Rejected":				case "NetConnection.Connect.AppShutdown":				case "NetConnection.Connect.InvalidApp":					dispatchEvent(new RemotingEvent(RemotingEvent.ERROR, __service, {} ) );					break;			}		}				private function onResult( result:Object ):void		{			dispatchEvent( new RemotingEvent( RemotingEvent.SUCCESS, __method, result ) );		}		private function onFault( result:Object ):void		{			dispatchEvent( new RemotingEvent( RemotingEvent.FAILURE, __method, result) );		}	}}